// Generated by LeetCodeContestHelper at 5/25/2024, 9:49:52 PM
// 100314. Block Placement Queries
// https://leetcode.com/contest/biweekly-contest-131/problems/block-placement-queries/

#define _USE_MATH_DEFINES
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <cmath>
#include <deque>
#include <forward_list>
#include <functional>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <regex>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <valarray>
#include <vector>

using namespace std;

vector<int> tree;
const int mx = (int)5 * 1e4 + 5;

void update(int index, int L, int R, int pos, int val) {
    if (L == R) {
        tree[index] = val;
        return;
    }
    int mid = (L + R) / 2;
    if (pos <= mid) {
        update(2 * index, L, mid, pos, val);
    } else {
        update(2 * index + 1, mid + 1, R, pos, val);
    }
    tree[index] = max(tree[2 * index], tree[2 * index + 1]);
}

int query(int index, int L, int R, int l, int r) {
    if (R < l || L > r) {
        return -1;
    }
    if (L >= l && R <= r) {
        return tree[index];
    }
    int mid = (L + R) / 2;
    return max(query(2 * index, L, mid, l, r),
               query(2 * index + 1, mid + 1, R, l, r));
}

class Solution {
   public:
    vector<bool> getResults(vector<vector<int>>& queries) {
        vector<bool> ans;
        set<int> st1;
        st1.insert(0);
        tree.clear();
        tree.resize(4 * mx, -1);
        for (auto& e : queries) {
            if (e[0] == 1) {
                int x = e[1];
                auto it = st1.upper_bound(x);
                if (it != st1.end()) {
                    update(1, 0, mx - 1, *it, *it - x);
                }
                --it;
                update(1, 0, mx - 1, x, x - *it);
                st1.insert(x);
            } else {
                int x = e[1], sz = e[2];
                auto it = --st1.lower_bound(x);
                int m = max(query(1, 0, mx - 1, 0, x), x - *it);
                ans.push_back(m >= sz || m == -1);
            }
        }
        return ans;
    }
};

// vector<bool> Solution::getResults(vector<vector<int>> queries)

int main() {
    cout << "*** 100314. Block Placement Queries ***" << endl << endl;

    Solution s0;

    {
        cout << "Test 1: ";

        vector<vector<int>> queries = {{1, 2}, {2, 3, 3}, {2, 3, 1}, {2, 2, 2}};
        vector<bool> ans0 = s0.getResults(queries);
        vector<bool> exp0 = {false, true, true};

        if (ans0 == exp0) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
            cout << "  Answer: ";
            for (bool i : ans0) {
                cout << i << " ";
            }
            cout << endl << "  Expect: ";
            for (bool i : exp0) {
                cout << i << " ";
            }
            cout << endl;
        }
    }

    {
        cout << "Test 2: ";

        vector<vector<int>> queries = {
            {1, 7}, {2, 7, 6}, {1, 2}, {2, 7, 5}, {2, 7, 6}};
        vector<bool> ans1 = s0.getResults(queries);
        vector<bool> exp1 = {true, true, false};

        if (ans1 == exp1) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
            cout << "  Answer: ";
            for (bool i : ans1) {
                cout << i << " ";
            }
            cout << endl << "  Expect: ";
            for (bool i : exp1) {
                cout << i << " ";
            }
            cout << endl;
        }
    }

    return 0;
}
