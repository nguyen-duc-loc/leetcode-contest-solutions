// Generated by LeetCodeContestHelper at 5/18/2025, 9:58:25 AM
// 100639. Grid Teleportation Traversal
// https://leetcode.com/contest/weekly-contest-450/problems/grid-teleportation-traversal/

#define _USE_MATH_DEFINES
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <cmath>
#include <deque>
#include <forward_list>
#include <functional>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <regex>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <valarray>
#include <vector>

using namespace std;

class Solution {
   public:
    int dx[4] = {1, 0, -1, 0};
    int dy[4] = {0, 1, 0, -1};

    int convert(int i, int j, int n) {
        return i * n + j;
    }

    pair<int, int> revert(int x, int n) {
        return make_pair(x / n, x % n);
    }

    int minMoves(vector<string>& matrix) {
        int m = (int)matrix.size(), n = (int)matrix[0].size();
        priority_queue<pair<int, int>, vector<pair<int, int>>,
                       greater<pair<int, int>>>
            q;
        vector<vector<int>> v(26);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] >= 'A' && matrix[i][j] <= 'Z') {
                    v[matrix[i][j] - 'A'].push_back(convert(i, j, n));
                }
            }
        }
        vector<bool> vis(m * n);
        vector<int> dist(m * n, INT_MAX);
        dist[0] = 0;
        int processed = 0;
        q.emplace(0, 0);
        while (!q.empty()) {
            auto t = q.top();
            q.pop();
            auto p = revert(t.second, n);
            if (vis[t.second]) {
                continue;
            }
            vis[t.second] = true;
            if (matrix[p.first][p.second] >= 'A' &&
                matrix[p.first][p.second] <= 'Z' &&
                !(processed & (1 << (matrix[p.first][p.second] - 'A')))) {
                for (auto& e : v[matrix[p.first][p.second] - 'A']) {
                    dist[e] = dist[t.second];
                    q.emplace(dist[e], e);
                }
                processed |= (1 << (matrix[p.first][p.second] - 'A'));
            }
            for (int k = 0; k < 4; k++) {
                int ni = p.first + dy[k];
                int nj = p.second + dx[k];
                auto c = convert(ni, nj, n);
                if (ni >= 0 && ni < m && nj >= 0 && nj < n &&
                    matrix[ni][nj] != '#' && !vis[c]) {
                    dist[c] = min(dist[c], dist[t.second] + 1);
                    q.emplace(dist[c], c);
                }
            }
        }
        return dist.back() == INT_MAX ? -1 : dist.back();
    }
};

// int Solution::minMoves(vector<string> matrix)

int main() {
    cout << "*** 100639. Grid Teleportation Traversal ***" << endl << endl;

    Solution s0;

    {
        cout << "Test 1: ";

        vector<string> matrix = {"A..", ".A.", "..."};
        int ans0 = s0.minMoves(matrix);
        int exp0 = 2;

        if (ans0 == exp0) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
            cout << "  Answer: " << ans0 << endl;
            cout << "  Expect: " << exp0 << endl;
        }
    }

    {
        cout << "Test 2: ";

        vector<string> matrix = {".#...", ".#.#.", ".#.#.", "...#."};
        int ans1 = s0.minMoves(matrix);
        int exp1 = 13;

        if (ans1 == exp1) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
            cout << "  Answer: " << ans1 << endl;
            cout << "  Expect: " << exp1 << endl;
        }
    }

    {
        cout << "Test 3: ";

        vector<string> matrix = {".#..#.", "CCEH.D", "..D.FB"};
        int ans1 = s0.minMoves(matrix);
        int exp1 = 4;

        if (ans1 == exp1) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
            cout << "  Answer: " << ans1 << endl;
            cout << "  Expect: " << exp1 << endl;
        }
    }

    return 0;
}
